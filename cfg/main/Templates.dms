container Templates: Using = "Units;Classifications;geometries;Classifications/TomTom"
{
	Template CreateNetwork_T
	{
		// begin case parameters
		unit<uint32> OrgDomain0;
		unit<uint32> DestDomain0;
		unit<uint32> RoadDomain0;
		unit<uint32> JunctionDomain;
		// end case parameters

		unit<uint32> OrgDomain := OrgDomain0
		{
			attribute<UniqueLocations> UniqueLocations_rel := rlookup(ipoint(geometry), ipoint(UniqueLocations/geometry));
			attribute<uint32>		   id_rel:= OrgDomain0/id_rel;
		}
		
		unit<uint32> DestDomain := DestDomain0
		{
			attribute<UniqueLocations> UniqueLocations_rel := rlookup(ipoint(geometry), ipoint(UniqueLocations/geometry));
			attribute<uint32>		   id_rel:= DestDomain0/id_rel;
		}
		
		attribute<BaseProjection>                      OrgLocations  (OrgDomain)      := orgDomain/geometry;
		attribute<BaseProjection>                      destLocations (DestDomain)     := destDomain/geometry;
		attribute<spoint>                              OrgLocations_spoint  (OrgDomain)      := orgDomain/Base_grid_1km_spoint_rel ;
		attribute<spoint>                              destLocations_spoint (DestDomain)     := destDomain/Base_grid_1km_spoint_rel ;
		
		unit<uint32> Locations := union_unit(orgDomain, destDomain)
		{
			attribute<BaseProjection>                  geometry                       := union_data(.,orgLocations, destLocations);
			attribute<spoint>                          as_spoint                      := union_data(.,OrgLocations_spoint, destLocations_spoint);
			attribute<bool>                            IsOrg                          := union_data(.,const(TRUE , OrgDomain), const(FALSE,DestDomain));
			attribute<bool>                            IsDest                         := union_data(.,const(FALSE, OrgDomain), const(TRUE ,DestDomain));
			attribute<uint32>                          Population                     := union_data(.,OrgDomain/Population, DestDomain/Population);
		}
		
		unit<uint32> UniqueLocations    := unique(Locations/geometry) 
		{ 
			attribute<BaseProjection>               geometry       := values;
			attribute<Locations>                    Locations_rel  := rlookup(geometry, Locations/geometry);
			attribute<OrgDomain>                    OrgDomain_rel  := rlookup(geometry, OrgLocations);
			attribute<uint32>						Org_id_rel	   := OrgDomain/id_rel[OrgDomain_rel];
			attribute<DestDomain>                   DestDomain_rel := rlookup(geometry, DestLocations);
			attribute<uint32>						Dest_id_rel	   := DestDomain/id_rel[DestDomain_rel];
			attribute<bool>                         IsOrg          := rjoin(geometry, Locations/geometry, Locations/IsOrg);
			attribute<uint32>                       Population     := Locations/Population[Locations_rel];
		}
		
		
		container CreateInitialWorkingNetwork
		{
			unit<uint32> Roads_with_unconnected_subnetworks_w_CarRoads := RoadDomain0
			{
				attribute<bool>                   IsCarRoad                := Direction != /Classifications/TomTom/Directions/V/nocars;
			}
			
			unit<uint32> Roads_with_unconnected_subnetworks_only_CarRoads := select(Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad)
			{
				attribute<BaseProjection>     geometry (arc)       := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/geometry);
				attribute<bool>               IsOneDirection       := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/IsOneDirection);
				attribute<km_hr>              KPH                  := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/KPH);
				attribute<Bool >              Connectable          := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/Connectable);
				attribute<RegioRoadCategory>  RRC_rel			   := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/RRC_rel);
				attribute<uint64>             F_JNCTID             := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/F_JNCTID);
				attribute<uint64>             T_JNCTID             := collect_by_cond(.,Roads_with_unconnected_subnetworks_w_CarRoads/IsCarRoad, Roads_with_unconnected_subnetworks_w_CarRoads/T_JNCTID);
				
				attribute<NodeSet_src>        Fsrc_1               := rlookup(F_JnctId, NodeSet_src/JnctIds);
				attribute<NodeSet_src>        Fsrc_2               := rlookup(T_JnctId, NodeSet_src/JnctIds);
				
				attribute<BaseProjection>     fromPoint            := first_point(geometry);
				attribute<BaseProjection>     toPoint              := last_point(geometry);
				
				unit<uint32> PointSet := union_unit(., .)
				{
					attribute<uint64>           JnctIds            := union_data(., F_JnctId, T_JnctId); 
					attribute<BaseProjection>   Points             := union_data(., fromPoint, toPoint);
					attribute<BaseProjection>   geometry           := points;
				}
				unit<uint32> NodeSet_src := unique(PointSet/JnctIds)
				{
					attribute<BaseProjection>   geometry           := PointSet/geometry[rlookup(JnctIds, PointSet/JnctIds)];
					attribute<uint64>           JnctIds            := values;
				}
				
				container Connectiveness := Templates/Check_Connectiveness_T(.,NodeSet_src, Fsrc_1, Fsrc_2);
			}
			
			//attribute<bool> Roads_isConnected (Roads_with_unconnected_subnetworks_only_CarRoads) := Roads_with_unconnected_subnetworks_only_CarRoads/Connectiveness/IsVerbonden;
			attribute<bool> Roads_isConnected (Roads_with_unconnected_subnetworks_only_CarRoads) := Roads_with_unconnected_subnetworks_only_CarRoads/Connectiveness/IsSterkVerbonden;
			//attribute<bool> Nodes_isConnected (Roads_with_unconnected_subnetworks_only_CarRoads/NodeSet_src) := Roads_with_unconnected_subnetworks_only_CarRoads/Connectiveness/NodesVerbonden;
			attribute<bool> Nodes_isConnected (Roads_with_unconnected_subnetworks_only_CarRoads/NodeSet_src) := Roads_with_unconnected_subnetworks_only_CarRoads/Connectiveness/NodesSterkVerbonden;

			unit<uint32> Roads := select(Roads_isConnected)
			{
				attribute<BaseProjection>     geometry (arc) := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/geometry);
				attribute<bool>               IsOneDirection := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/IsOneDirection);
				attribute<km_hr>              KPH            := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/KPH);
				attribute<Bool >              Connectable    := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/Connectable);
				attribute<RegioRoadCategory>  RRC_rel		 := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/RRC_rel);
				attribute<uint64>			  F_JnctId		 := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/F_JnctId);
				attribute<uint64>			  T_JnctId		 := collect_by_cond(.,Roads_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/T_JnctId);
				
				unit<uint32> UqGeomPointSet:= select(Nodes_isConnected) 
				{
					attribute<BaseProjection> geometry := collect_by_cond(.,Nodes_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/NodeSet_src/geometry);
					attribute<uint64> JnctIds := collect_by_cond(.,Nodes_isConnected, Roads_with_unconnected_subnetworks_only_CarRoads/NodeSet_src/JnctIds);
					attribute<uint64> values := JnctIds;
					attribute<bool>	  connectable:= any(../Connectable, F1) || any(../Connectable, F2);
					attribute<uint32> conn_count:= pcount(F1) + pcount(F2);
				}
				attribute<UqGeomPointSet> F1 := rlookup(F_JnctId, UqGeomPointSet/values);
				attribute<UqGeomPointSet> F2 := rlookup(T_JnctId, UqGeomPointSet/values);
				
				container Connectiveness := Templates/Check_Connectiveness_T(.,UqGeomPointSet, F1, F2);
			}
			
			/*unit<uint32> Roads := arc2segm(Road_linestrings/geometry)
			{
				attribute<km_hr>              KPH                  := sequence_rel->KPH;
				attribute<bool>               IsOneDirection       := sequence_rel->IsOneDirection;
				attribute<bool>               Connectable          := sequence_rel->Connectable;
				unit<uint32> PointSet := union_unit(., .)
				{
					attribute<BaseProjection>   geometry     := union_data(., point, NextPoint);
				}
				unit<uint32> UqGeomPointSet := unique(PointSet/geometry)
				{ 
					attribute<BaseProjection> geometry := values;
				}
				attribute<UqGeomPointSet> F1 := rlookup(point, UqGeomPointSet/values);
				attribute<UqGeomPointSet> F2 := rlookup(nextpoint, UqGeomPointSet/values);
				
				// for checking and visualisation only
				container Connectiveness := Templates/Check_Connectiveness_T(.,UqGeomPointSet, F1, F2);
				attribute<BaseProjection> geometry(arc) := points2sequence(PointSet/geometry, convert(id(PointSet) % #., .));
			}*/
			
			unit<uint32> LinkSet_Calc := connect_ne(Roads/geometry, uint32(Roads/Connectable), UniqueLocations/geometry, const(0, UniqueLocations))
			{
				attribute<BaseProjection>  geometry(arc);
				attribute<km_hr>           KPH                  := MakeDefined(arc_rel->KPH, ModelParameters/Advanced/CarDefaultSpeed_low);
				attribute<bool>            IsOneDirection       := Makedefined(arc_rel->IsOneDirection, false);
				attribute<RegioRoadCategory> RRC_rel			:= MakeDefined(arc_rel->RRC_rel, RegioRoadCategory/V/Simulated_connectors);
				attribute<uint32>		   F1					:= arc_rel->F1[uint32];
				attribute<uint32>		   F2					:= arc_rel->F2[uint32];
				attribute<bool>			   isconnector			:= isnull(arc_rel);
				attribute<bool>			   f_unchanged_is		:= first_point(geometry) == Roads/UqGeomPointSet/geometry[arc_rel->F1];
				attribute<bool>			   f_unchanged          := point_isNearby(first_point(geometry), first_point(arc_rel->geometry), 1d); //point(1d, 1d, dpoint));
				attribute<bool>			   t_unchanged_is		:= last_point(geometry) == Roads/UqGeomPointSet/geometry[arc_rel->F2];
				attribute<bool>			   t_unchanged          := point_isNearby(last_point(geometry), last_point(arc_rel->geometry), 1d);//point(1d, 1d, BaseProjection));
				
				unit<uint32> location_connectors:= select(isconnector) {
					attribute<BaseProjection>  geometry (arc):= collect_by_cond(., isconnector, ../geometry);
					attribute<km_hr>		   KPH				:= const(ModelParameters/Advanced/CarDefaultSpeed_low,.,km_hr);
					attribute<bool>			   IsOneDirection	:= const(false,.,bool);
					attribute<RegioRoadCategory> RRC_rel		:= const(RegioRoadCategory/V/Simulated_connectors,.,RegioRoadCategory);
					attribute<BaseProjection>  od_point:= first_point(geometry);
					attribute<BaseProjection>  cutpoint:= last_point(geometry);
					attribute<UniqueLocations> ul_id:= rlookup(od_point, UniqueLocations/geometry);
					attribute<uint32> F1:= ul_id[uint32] + #Roads/UqGeomPointSet;
					attribute<uint32> F2:= unique_cutpoints/suggested_node_id[rlookup(cutpoint, unique_cutpoints/Values)];
					
					// list connectable nodes to which the cutpoint may have snapped
					unit<uint32> existing_connectable_nodes:= select_with_org_rel(Roads/UqGeomPointSet/Connectable) {
						attribute<BaseProjection> 	Geometry:= org_rel->Geometry;
						attribute<uint32>			conn_count:= org_rel->conn_count;
						attribute<unique_cutpoints>	uc_rel:= rlookup(Geometry, unique_cutpoints/Values);
					}
					// unique cutpoints (may have snapped to existing_connectable_nodes)
					unit<uint32> unique_cutpoints:= unique(cutpoint) {
						attribute<Roads/UqGeomPointSet> ecn_rel:= existing_connectable_nodes/org_rel[max_index(existing_connectable_nodes/conn_count, existing_connectable_nodes/uc_rel)];  //prefer the node location with the most connections.
						attribute<uint32>	suggested_node_id:= makedefined(ecn_rel[uint32], #Roads/UqGeomPointSet + #UniqueLocations + id(.)[uint32]); // if not on a connectable existing node, identify as new node
					}
				}
				unit<uint32> unchanged_links:= select(f_unchanged && t_unchanged) {
					attribute<BaseProjection>  geometry (arc)	:= collect_by_cond(., f_unchanged && t_unchanged, ../geometry);
					attribute<km_hr>		   KPH				:= collect_by_cond(., f_unchanged && t_unchanged, ../KPH);
					attribute<bool>			   IsOneDirection	:= collect_by_cond(., f_unchanged && t_unchanged, ../IsOneDirection);
					attribute<RegioRoadCategory> RRC_rel		:= collect_by_cond(., f_unchanged && t_unchanged, ../RRC_rel);
					attribute<uint32>		   F1				:= collect_by_cond(., f_unchanged && t_unchanged, ../F1);
					attribute<uint32>		   F2				:= collect_by_cond(., f_unchanged && t_unchanged, ../F2);
					attribute<Roads>		   org_roads_id		:= collect_by_cond(., f_unchanged && t_unchanged, ../Nr_OrgEntity);
				}
				unit<uint32> changed_links:= select(!isconnector && (!f_unchanged || !t_unchanged)) {
					attribute<BaseProjection>  geometry (arc)	:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../geometry);
					attribute<km_hr>		   KPH				:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../KPH);
					attribute<bool>			   IsOneDirection	:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../IsOneDirection);
					attribute<RegioRoadCategory> RRC_rel		:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../RRC_rel);
					attribute<bool>			   f_notchanged		:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../f_unchanged);
					attribute<bool>			   t_notchanged		:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../t_unchanged);
					attribute<uint32>		   org_F1			:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../F1);
					attribute<uint32>		   org_F2			:= collect_by_cond(., !isconnector && (!f_unchanged || !t_unchanged), ../F2);
					attribute<uint32>		   F1				:= f_notchanged ? org_F1 : location_connectors/F2[rlookup(first_point(geometry), location_connectors/cutpoint)];
					attribute<uint32>		   F2				:= t_notchanged ? org_F2 : location_connectors/F2[rlookup(last_point(geometry), location_connectors/cutpoint)];
					attribute<Roads>		   org_roads_id		:= collect_by_cond(.,  !isconnector && (!f_unchanged || !t_unchanged), ../Nr_OrgEntity);
					
					unit<uint32> sel_nulls:= select(isnull(F1) || isnull(F2)) {
						attribute<BaseProjection>  geometry (arc)   := collect_by_cond(., isnull(F1) || isnull(F2), ../geometry);
						attribute<BaseProjection>  fpoint			:= first_point(geometry);
						attribute<BaseProjection>  tpoint			:= last_point(geometry);
						attribute<BaseProjection>  org_fpoint		:= collect_by_cond(., isnull(F1) || isnull(F2), Roads/UqGeomPointSet/geometry[../org_F1]);
						attribute<BaseProjection>  org_tpoint		:= collect_by_cond(., isnull(F1) || isnull(F2), Roads/UqGeomPointSet/geometry[../org_F2]);
						attribute<bool>			   f_notchanged     := collect_by_cond(., isnull(F1) || isnull(F2), ../f_notchanged);
						attribute<bool>			   t_notchanged     := collect_by_cond(., isnull(F1) || isnull(F2), ../t_notchanged);
					}
				}
				
			}
			
			unit<uint32> LinkSet_Write := union_unit(LinkSet_Calc/unchanged_links, LinkSet_Calc/changed_links, LinkSet_Calc/location_connectors),	StorageName = "= '%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/Linkset_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'"
			{
				attribute<BaseProjection>  geometry(arc)		:= union_data(.,LinkSet_Calc/unchanged_links/geometry, 		LinkSet_Calc/changed_links/geometry, 		LinkSet_Calc/location_connectors/geometry);
				attribute<km_hr>           KPH                  := union_data(.,LinkSet_Calc/unchanged_links/KPH, 			LinkSet_Calc/changed_links/KPH, 			LinkSet_Calc/location_connectors/KPH);
				attribute<bool>            IsOneDirection       := union_data(.,LinkSet_Calc/unchanged_links/IsOneDirection,LinkSet_Calc/changed_links/IsOneDirection, 	LinkSet_Calc/location_connectors/IsOneDirection);
				attribute<RegioRoadCategory> RRC_rel    		:= union_data(.,LinkSet_Calc/unchanged_links/RRC_rel,		LinkSet_Calc/changed_links/RRC_rel, 		LinkSet_Calc/location_connectors/RRC_rel);
				attribute<uint32>  		   F_node				:= union_data(.,LinkSet_Calc/unchanged_links/F1,			LinkSet_Calc/changed_links/F1, 				LinkSet_Calc/location_connectors/F1);
				attribute<uint32>  		   T_node				:= union_data(.,LinkSet_Calc/unchanged_links/F2,			LinkSet_Calc/changed_links/F2, 				LinkSet_Calc/location_connectors/F2);
				attribute<bool>            IsOD_connection_road := union_data(.,const(False,LinkSet_Calc/unchanged_links,bool),const(False,LinkSet_Calc/changed_links,bool),const(True,LinkSet_Calc/location_connectors,bool));
				attribute<Roads>		   org_roads_id		    := union_data(., LinkSet_Calc/unchanged_links/org_roads_id, LinkSet_Calc/changed_links/org_roads_id,	const(0 / 0, LinkSet_Calc/location_connectors, Roads));
			}
			
			unit<uint32> LinkSet_Read: StorageName = "= '%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/Linkset_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'", StorageReadOnly = "True"
			{
				attribute<BaseProjection>  geometry(arc);
				attribute<km_hr>           KPH;
				attribute<bool>            IsOneDirection;
				attribute<RegioRoadCategory> RRC_rel;
				attribute<uint32>  		   F_node;
				attribute<uint32>  		   T_node;
				attribute<bool>            IsOD_connection_road;
				attribute<Roads>		   org_roads_id;
			}
			
			unit<uint32> LinkSet := LinkSet_Read
			{
				attribute<km>              LengthKm       := convert(arc_length(geometry, float64)[m], km);
				attribute<min_f>           Minutes        := MakeDefined(convert((LengthKm / KPH), min_f), 0.0001[min_f]);
				attribute<s_f>             impedance      := convert(minutes, s_f) + Float64(CorrectImpedanceForCrossroads/impedance_Start + CorrectImpedanceForCrossroads/impedance_End);
				attribute<NodeSet>         F1             := rlookup(F_node, NodeSet/Values); //node from the OD towards the network
				attribute<NodeSet>         F2             := rlookup(T_node, NodeSet/Values); //network node to which the the OD is connected 
 
				unit<uint32> PointSet := union_unit(., .);
				unit<uint32> Subnetworks:= connected_parts(F1, F2);
			}

			unit<uint32> NodeSet := unique(union_data(LinkSet/PointSet, LinkSet/F_node, LinkSet/T_node))
			{
				attribute<uint32>   		NrConnectedLinks := pcount(LinkSet/F1) + pcount(LinkSet/F2);
				attribute<bool>				OD_node:= any(LinkSet/IsOD_connection_road, LinkSet/F1);
				attribute<BaseProjection> 	Geometry:= makedefined(first(first_point(LinkSet/Geometry), LinkSet/F1), first(last_point(LinkSet/Geometry), LinkSet/F2));
				
				unit<uint32> OD_nodes:= select_with_org_rel(OD_node) {
					attribute<BaseProjection> geometry:= org_rel->Geometry;
				}
			}
						
 			container CorrectImpedanceForCrossroads
			// hiermee wordt voor ieder begin en eind node het aantal geconnecte links bepaald
			// dit bepaalt of het een bocht (2 links), zijweg (3 links), kruising (4 links) of complexe kruising (meer dan 4 links) is
			// afhankelijk van dit aantal wordt een aantal seconden opgeteld bij de totale impedance
			{
				// helft van de opgegeven waarden omdat er zowel bij begin als einde een factor wordt opgeteld
				parameter<s>       Impedance2Links    := 0[s];
				parameter<s>       Impedance3Links    := 2[s];
				parameter<s>       Impedance4Links    := 5[s];
				parameter<s>       Impedance_gt4Links := 6[s];

				attribute<uint32>  Start (LinkSet)     := NodeSet/NrConnectedLinks[LinkSet/F1];
				attribute<uint32>  End   (LinkSet)     := NodeSet/NrConnectedLinks[LinkSet/F2];
			
				attribute<s> impedance_Start (LinkSet):=
					switch(
						 case(Start <= 2, Impedance2Links)
						,case(Start  = 3, Impedance3Links)
						,case(Start  = 4, Impedance4Links)
						,Impedance_gt4Links
					);
			
				attribute<s> impedance_End (LinkSet):=
					switch(
						 case(End <= 2, Impedance2Links)
						,case(End  = 3, Impedance3Links)
						,case(End  = 4, Impedance4Links)
						,Impedance_gt4Links
					);
			}
  		}
		
		container CreateMoreEfficientNetwork
		{
			unit<uint8> Iter := range(uint8, 0[uint8], ModelParameters/NumberOfItersForNetworkCleanUp)
			{
				attribute<string> name := 'Iter_'+string(id(.));
				attribute<string> prevname := MakeDefined(name[sub_or_null(ID(.),1b)], 'Start');
				attribute<string> Label := name, DialogType = "LabelText";
				attribute<uint32> nrofarc_na_iter := ='union_data(., '+AsList('OptimiseNetwork/'+name+'/IntermediateLinkSet/count_arcs', ',')+')'; 
			}
			
			unit<uint32> LinkSet_src     := CreateInitialWorkingNetwork/LinkSet {attribute<LinkSet_src> ItmLinkSet_rel:= id(.);}
			unit<uint32> NodeSet_src     := CreateInitialWorkingNetwork/NodeSet
			{
//				attribute<BaseProjection_ip> geometry      := CreateInitialWorkingNetwork/NodeSet/geometry;
				// attribute<bool>              WillBeDeleted := (pcount(FinalLinkSet/F1) + pcount(FinalLinkSet/F2)) == 0;
			}

			unit<uint64> Nodeset_x_NodeSet := combine_unit_uint64(NodeSet_src, NodeSet_src);
			
			container OptimiseNetwork := 
				for_each_ne(
					Iter/name
					, 'OptimiseNetwork_T('+quote(Iter/name)+')'
				)
			{
				container LastIter := =last(Iter/name);
			}
			
			
			unit<uint32> FinalNodeSet_Calc := select_with_org_rel(pcount(LastLinkSet/F1)+pcount(LastLinkSet/F2) > 0);
			unit<uint32> FinalNodeSet_Write := FinalNodeSet_Calc
				,	StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/FinalNodeSet_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'"
			{
				attribute<BaseProjection> geometry := org_rel->geometry;
				attribute<bool>			  OD_node  := org_rel->OD_node;
			}
			
			unit<uint32> LastLinkSet := OptimiseNetwork/LastIter/IntermediateLinkSet;
			unit<uint32> FinalLinkSet_Write := LastLinkSet,	StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/FinalLinkSet_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'" 
			{
				attribute<FinalNodeSet_Calc> F1                   := invert(FinalNodeSet_Calc/org_rel)[LastLinkSet/F1];
				attribute<FinalNodeSet_Calc> F2                   := invert(FinalNodeSet_Calc/org_rel)[LastLinkSet/F2];
				attribute<s_f>               Impedance            := LastLinkSet/Impedance;
				attribute<km>                LengthKm             := LastLinkSet/LengthKm;
				attribute<bool>              IsOneDirection       := LastLinkSet/IsOneDirection;
				attribute<bool>              IsOD_connection_road := LastLinkSet/IsOD_connection_road;
			}
			
			unit<uint32> FinalNodeSet : StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/FinalNodeSet_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'", StorageReadOnly = "True"
			{
				attribute<BaseProjection> geometry;
				attribute<bool>			  OD_node;
				attribute<.> OrgNode_rel  (OrgDomain)  := OD_nodes/org_rel[rlookup(OrgDomain/geometry,  OD_nodes/geometry)];
				attribute<.> DestNode_rel (DestDomain) := OD_nodes/org_rel[rlookup(DestDomain/geometry, OD_nodes/geometry)];	
				unit<uint32> OD_nodes:= select_with_org_rel(OD_node) {
					attribute<BaseProjection> geometry:= org_rel->geometry;
				}
			}
			unit<uint32> ChangesTracker_Write := LinkSet_src, StorageName = "= '%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/Linkset_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'" {
				attribute<LastLinkSet> FinalLinkSet_rel:= OptimiseNetwork/LastIter/OrgLinkSet/ItmLinkSet_rel;
			}
			
			unit<uint32> FinalLinkSet_Read: StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/FinalLinkSet_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_Pop-'+string(ModelParameters/PopVersie)+'.fss'", StorageReadOnly = "True"
			{
				attribute<FinalNodeSet> F1;
				attribute<FinalNodeSet> F2;
				attribute<s_f>          Impedance;
				attribute<km>           LengthKm;
				attribute<bool>         IsOneDirection;
				attribute<bool>         IsOD_connection_road;
				attribute<km>			Length_Direct:= convert(dist(FirstPoint, LastPoint)[m], km);
				
				// For visualisation
				attribute<BaseProjection>                  FirstPoint                     := FinalNodeSet/Geometry[F1];
				attribute<BaseProjection>                  LastPoint                      := FinalNodeSet/Geometry[F2];
				attribute<BaseProjection>                  geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
				unit<uint32> PointSet := union_unit(.,.)
				{
					attribute<BaseProjection>              Point   := Union_Data(., ../FirstPoint, ../LastPoint);
					attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
					attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
				}
			}
			unit<uint32> ChangesTracker_Read:= LinkSet_src, StorageName = "= propvalue(ChangesTracker_Write, 'StorageName')", StorageReadOnly = "True" {
				attribute<FinalLinkSet> FinalLinkSet_rel;
			}
			unit<uint32> FinalLinkSet := FinalLinkSet_Read
			{
				attribute<bool>         IsOneDirection := FinalLinkSet_Read/IsOneDirection;
				attribute<s_f>          Impedance      := FinalLinkSet_Read/Impedance;
				attribute<km>           LengthKm       := FinalLinkSet_Read/LengthKm;
				// For visualisation
				attribute<BaseProjection>                  FirstPoint                     := FinalNodeSet/Geometry[F1];
				attribute<BaseProjection>                  LastPoint                      := FinalNodeSet/Geometry[F2];
				attribute<BaseProjection>                  geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
				unit<uint32> PointSet := union_unit(.,.)
				{
					attribute<BaseProjection>              Point   := Union_Data(., ../FirstPoint, ../LastPoint);
					attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
					attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
				}
				// container Connectiveness := Templates/Check_Connectiveness_T_adhoc(.,FinalNodeSet, F1, F2);
				
				attribute<bool>           IsOD_connection_road       := FinalLinkSet_Read/IsOD_connection_road;
				
				unit<uint32> Without_OD_connection_roads := select_with_attr_by_org_rel(.,!IsOD_connection_road);
				
				unit<uint32> Export := Without_OD_connection_roads
				, StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/Network_Cleaned_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_'+expand(., '%DateTime%')+'.gpkg'"
				, StorageType = "gdalwrite.vect"
				{
					attribute<BaseProjection> geometry     (arc) := Without_OD_connection_roads/geometry;
					attribute<float32>        Impedance          := float32(Without_OD_connection_roads/Impedance);
					attribute<float32>        LengthKm           := float32(Without_OD_connection_roads/LengthKm);
					attribute<float32>        IsOneDir           := float32(Without_OD_connection_roads/IsOneDirection);
				}
				
				//adhoc
				attribute<bool>			  Is_inNL:= point_in_polygon(FirstPoint, RegionalUnits/country/subset/geometry) = 23 || point_in_polygon(LastPoint, RegionalUnits/country/subset/geometry) = 23;
				
				unit<uint32> Roads_NL:= select_with_attr_by_org_rel(.,Is_inNL);
				unit<uint32> Export_NL := Roads_NL
				, StorageName = "='%LocalDataProjDir%/'+ProjName+'/'+ModelParameters/CountryFolder+'/IN_NL/Network_Cleaned_O-'+ModelParameters/OrgGridsize+'_D-'+/ModelParameters/DestGridsize+'_'+expand(., '%DateTime%')+'.gpkg'"
				, StorageType = "gdalwrite.vect"
				{
					attribute<BaseProjection> geometry     (arc) := Roads_NL/geometry;
					attribute<float32>        Impedance          := float32(Roads_NL/Impedance);
					attribute<float32>        LengthKm           := float32(Roads_NL/LengthKm);
					attribute<float32>        IsOneDir           := float32(Roads_NL/IsOneDirection);
				}
				
				
				container store 
				{
					parameter<bool>    store                    :=  True, explicitsuppliers = "Export";
				}
			}
			
			
			Template OptimiseNetwork_T
			{
				parameter<string> IterName;
				///
				unit<uint32> PrevIntermediateLinkSet := =IterName != 'Iter_0' ? Iter/prevname[rlookup(IterName, Iter/name)]+'/IntermediateLinkSet' : 'LinkSet_src';
				unit<uint32> PrevOrgLinkSet:= =IterName != 'Iter_0' ? Iter/prevname[rlookup(IterName, Iter/name)]+'/OrgLinkSet' : 'LinkSet_src';
				
				unit<uint32> UniqueLocations := NetwerkSpec/UniqueLocations
				{
					attribute<NodeSet> Node_rel                    := NodeSet/OD_nodes/org_rel[rlookup(geometry, NodeSet/OD_nodes/geometry)]; 
					attribute<LinkSet> Link_rel                    := rlookup(Node_rel, LinkSet/F1);
					attribute<NodeSet> Node_rel_if_new_ODlink      := Link_rel -> F2;
					attribute<NodeSet> Node_rel_of_link_to_network := !(link_rel -> IsOD_connection_road) ? Node_rel : Node_rel_if_new_ODlink;
					
				}
				
				unit<uint32> LinkSet := PrevIntermediateLinkSet
				{
					attribute<bool>                            IsPartOfJunctionFreeSection    := NodeSet/WillBeDeleted[F1] || NodeSet/WillBeDeleted[F2];
					attribute<bool>                            IsInsideJunctionFreeSection    := NodeSet/WillBeDeleted[F1] && NodeSet/WillBeDeleted[F2];
					attribute<bool>                            IsOnBorderOfJunctionFreeSection:= IsPartOfJunctionFreeSection && !IsInsideJunctionFreeSection;
					attribute<bool>                            IsFinalLink                    := !IsPartOfJunctionFreeSection;
					attribute<bool>                            IsOneDirection                 := PrevIntermediateLinkSet/IsOneDirection;
					
					attribute<UnchangedLinkSet>				   UnchangedLink_rel			  := invert(UnchangedLinkSet/org_rel);
					attribute<LinksInsideJunctionFreeSection>  LinksInsideJFS_rel			  := invert(LinksInsideJunctionFreeSection/org_rel);
					attribute<ConnectorLink>				   ConnectorLink_rel			  := invert(ConnectorLink/org_rel);
					attribute<JunctionFreeSection>			   JFS_rel						  := MakeDefined(LinksInsideJunctionFreeSection/JunctionFreeSection_rel[LinksInsideJFS_rel], ConnectorLink/JunctionFreeSection_rel[ConnectorLink_rel]);
					attribute<LinkSet_cleanedforJFS>		   LinkSet_cleanedforJFS_rel	  := MakeDefined(UnchangedLink_rel[uint32], JFS_rel[uint32] + #UnchangedLinkSet)[LinkSet_cleanedforJFS];
					attribute<IntermediateLinkSet>			   ItmLinkSet_rel				  := LinkSet_cleanedforJFS/ItmLinkSet_rel[LinkSet_cleanedforJFS_rel];
					
					// For visualisation
					attribute<BaseProjection_ip>               geometry (arc)                 := PrevIntermediateLinkSet/geometry[BaseProjection_ip];
				}
				unit<uint32> OrgLinkSet:= PrevOrgLinkSet {
					attribute<LinkSet> PrevLinkSet_rel:= PrevOrgLinkSet/ItmLinkSet_rel;
					attribute<IntermediateLinkSet> ItmLinkSet_rel:= LinkSet/ItmLinkSet_rel[PrevLinkSet_rel];
				}
				unit<uint32> NodeSet  := NodeSet_src
				{
					attribute<uint32>                          NrConnectedLinks               := pcount(LinkSet/F1) + pcount(LinkSet/F2);
					attribute<bool>                            BordersWithOneDirectionalRoad  := LinkSet/IsOneDirection[invert(LinkSet/F1)] || LinkSet/IsOneDirection[invert(LinkSet/F2)];
					attribute<bool>                            WillBeDeleted                  := NrConnectedLinks == 2  // 2 connectinglinks means intermediary without junction
																									&& !IsOD_connection_road;
					attribute<bool>                            IsOD_connection_road           := pcount(UniqueLocations/Node_rel) != 0 // if there are node_rel's then it is an OD-point.
																									|| pcount(UniqueLocations/Node_rel_of_link_to_network) != 0; //if there are nodes related to the network to the OD-point, then it is the cnnecting node

					//Forward relations
					attribute<JunctionFreeSection>             JunctionFreeSection_rel        := ConnectedParts/JunctionFreeSection_rel[ConnectedParts_rel];
					attribute<ConnectedParts>                  ConnectedParts_rel             := ConnectedParts/PartNr;
					
					attribute<bool>                            IsOrgDest_location             := OD_node;
					attribute<uint32>                          NrConnectedLinks_in_LinkSet_cleanedforJFS := pcount(LinkSet_cleanedforJFS/F1) + pcount(LinkSet_cleanedforJFS/F2);
					attribute<bool>                            IsDeadEnd_and_NotOD            := NrConnectedLinks_in_LinkSet_cleanedforJFS == 1 && !IsOrgDest_location;
					attribute<bool>                            IsDeadEnd            		  := NrConnectedLinks_in_LinkSet_cleanedforJFS == 1;
					
					// For visualisation
					attribute<BaseProjection_ip>               geometry                       := NodeSet_src/geometry[BaseProjection_ip];
				}

				unit<uint32> LinksInsideJunctionFreeSection := select(LinkSet/IsInsideJunctionFreeSection), Descr = "Those links that are in the junction free section"
				{
					attribute<s_f>                             impedance                      := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/impedance);
					attribute<km>                              LengthKm                       := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/LengthKm);
					attribute<NodeSet>                         F1                             := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/F1);
					attribute<NodeSet>                         F2                             := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/F2); 
					attribute<bool>                            IsOneDirection                 := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/IsOneDirection); 
					attribute<JunctionFreeSection>             JunctionFreeSection_rel        := NodeSet/JunctionFreeSection_rel[F1];
					
					attribute<LinkSet>						   org_rel						  := collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, id(LinkSet));
					
					//For visualisation
					attribute<BaseProjection_ip>                  geometry  (arc)                :=  collect_by_cond(LinksInsideJunctionFreeSection, LinkSet/IsInsideJunctionFreeSection, LinkSet/geometry);
				}
				
				unit<uint32> ConnectedParts := connected_parts(LinksInsideJunctionFreeSection/F1, LinksInsideJunctionFreeSection/F2)
				{
					attribute<NodeSet>                         FirstNode_rel                   := invert(PartNr);
					attribute<bool>                            IsJunctionFreeSection           := NodeSet/WillBeDeleted[FirstNode_rel];
					attribute<JunctionFreeSection>             JunctionFreeSection_rel         := recollect_by_cond(ConnectedParts/IsJunctionFreeSection, ID(JunctionFreeSection));
				}
				
				unit<uint32> ConnectorLink := select_with_org_rel(LinkSet/IsOnBorderOfJunctionFreeSection)
				, Descr = "Those links that connect the unchanged links with the junction free links"
				{
					attribute<NodeSet>                         F1                             := LinkSet/F1[org_rel];
					attribute<NodeSet>                         F2                             := LinkSet/F2[org_rel]; 
					attribute<bool>                            is_F1_deleted                  := NodeSet/WillBeDeleted[F1];
					attribute<NodeSet>                         F_keep                         := is_F1_deleted ? F2 : F1; // Unchanged Node
					attribute<NodeSet>                         F_delete                       := is_F1_deleted ? F1 : F2; // Node in JunctionFreeSection
					attribute<JunctionFreeSection>             JunctionFreeSection_rel        := NodeSet/JunctionFreeSection_rel[F_delete];
					attribute<NodeSet>                         NodeSet_rel                    := F_keep;
					attribute<s_f>                             Impedance                      := LinkSet/Impedance[org_rel];
					attribute<km>                              LengthKm                       := LinkSet/LengthKm[org_rel];
					attribute<bool>                            IsOneDirection                 := LinkSet/IsOneDirection[org_rel];
					
					//For visualisation
					attribute<BaseProjection_ip>               geometry  (arc)                := LinkSet/geometry[org_rel];
				}
				
				
				unit<uint32> JunctionFreeSection := select(ConnectedParts/IsJunctionFreeSection)
				, Descr = "Those nodes that are redundant, because there are no junctions on the links"
				{
					attribute<ConnectorLink>                   First_ConnectorLink_rel        := min(id(ConnectorLink), ConnectorLink/JunctionFreeSection_rel); //todo sneller
					attribute<ConnectorLink>                   Last_ConnectorLink_rel         := max(id(ConnectorLink), ConnectorLink/JunctionFreeSection_rel); //todo sneller
					attribute<bool>                            IsDisconnected                 := First_ConnectorLink_rel > Last_ConnectorLink_rel;
					
					attribute<s_f>                             Aggregated_Impedence           := sum(LinksInsideJunctionFreeSection/impedance, LinksInsideJunctionFreeSection/JunctionFreeSection_rel);
					attribute<s_f>                             First_ConnectorLink_Impedance  := ConnectorLink/Impedance[First_ConnectorLink_rel];
					attribute<s_f>                             Last_ConnectorLink_Impedance   := ConnectorLink/Impedance[Last_ConnectorLink_rel];
					attribute<s_f>                             Total_Impedance                := Aggregated_Impedence + First_ConnectorLink_Impedance + Last_ConnectorLink_Impedance;
					
					attribute<km>                              Aggregated_LengthKm            := sum(LinksInsideJunctionFreeSection/LengthKm, LinksInsideJunctionFreeSection/JunctionFreeSection_rel);
					attribute<km>                              First_ConnectorLink_LengthKm   := ConnectorLink/LengthKm[First_ConnectorLink_rel];
					attribute<km>                              Last_ConnectorLink_LengthKm    := ConnectorLink/LengthKm[Last_ConnectorLink_rel];
					attribute<km>                              Total_LengthKm                 := Aggregated_LengthKm + First_ConnectorLink_LengthKm + Last_ConnectorLink_LengthKm;
					
					attribute<NodeSet>                         Fa                             := ConnectorLink/NodeSet_rel[First_ConnectorLink_rel];
					attribute<NodeSet>                         Fb                             := ConnectorLink/NodeSet_rel[Last_ConnectorLink_rel];  
					
					attribute<NodeSet>                         F1                             :=  First_ConnectorLink_rel -> F1 == Fa ? Fa : Fb;
					attribute<NodeSet>                         F2                             :=  First_ConnectorLink_rel -> F1 == Fa ? Fb : Fa;
					
					attribute<bool>                            First_ConnectorLink_IsOneDirection := ConnectorLink/IsOneDirection[First_ConnectorLink_rel];
					attribute<bool>                            Last_ConnectorLink_IsOneDirection  := ConnectorLink/IsOneDirection[Last_ConnectorLink_rel];
					attribute<bool>                            Links_InsideJFS_IsOneDirection     := all(LinksInsideJunctionFreeSection/IsOneDirection, LinksInsideJunctionFreeSection/JunctionFreeSection_rel);
					
					attribute<bool>                            IsOneDirection                     := First_ConnectorLink_IsOneDirection && Last_ConnectorLink_IsOneDirection && Links_InsideJFS_IsOneDirection;
					attribute<bool>                            IsOD_connection_road               := const(FALSE,.);
					
					//For visualisation
					attribute<BaseProjection_ip>               FirstPoint                     := NodeSet/Geometry[F1];
					attribute<BaseProjection_ip>               LastPoint                      := NodeSet/Geometry[F2];
					attribute<BaseProjection_ip>               geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
					unit<uint32> PointSet := union_unit(.,.)
					{
						attribute<BaseProjection_ip>           Point   := Union_Data(., ../FirstPoint, ../LastPoint);
						attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
						attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
					}
				}
				unit<uint32> DisconnectedJunctionFreeSection := select_with_attr_by_cond(JunctionFreeSection, JunctionFreeSection/IsDisconnected);
				
				unit<uint32> UnchangedLinkSet := select_with_org_rel(LinkSet/IsFinalLink) //todo sneller zonder org_rel
				, Descr = "Those links that can be used without changes, i.e. no nodes need to be removed"
				{
					attribute<NodeSet>                         F1                             := LinkSet/F1[org_rel];
					attribute<NodeSet>                         F2                             := LinkSet/F2[org_rel];
					attribute<s_f>                             impedance                      := LinkSet/impedance[org_rel];
					attribute<km>                              LengthKm                       := LinkSet/LengthKm[org_rel];
					attribute<bool>                            IsOneDirection                 := LinkSet/IsOneDirection[org_rel];
					attribute<bool>                            IsOD_connection_road           := LinkSet/IsOD_connection_road[org_rel];
					
					//For visualisation
					attribute<BaseProjection_ip>                  FirstPoint                     := NodeSet/geometry[F1];
					attribute<BaseProjection_ip>                  LastPoint                      := NodeSet/geometry[F2];
					attribute<BaseProjection_ip>                  geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
					unit<uint32> PointSet := union_unit(.,.)
					{
						attribute<BaseProjection_ip>              Point   := Union_Data(., ../FirstPoint, ../LastPoint);
						attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
						attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
					}
				}
				
				unit<uint32> LinkSet_cleanedforJFS := union_unit(UnchangedLinkSet, JunctionFreeSection)
				, Descr = "The final link set"
				{
					attribute<NodeSet>                         F1                             := union_data(., UnchangedLinkSet/F1, JunctionFreeSection/F1);
					attribute<NodeSet>                         F2                             := union_data(., UnchangedLinkSet/F2, JunctionFreeSection/F2);
					attribute<s_f>                             impedance_org                  := union_data(., UnchangedLinkSet/impedance, JunctionFreeSection/Total_Impedance);
					attribute<s_f>                             impedance                      := !IsOneDirection ? MakeDefined(Find_DuplicateLinks/min_impedance[Find_DuplicateLinks_rel],impedance_org) : impedance_org;

					attribute<km>                              LengthKm_org                   := union_data(., UnchangedLinkSet/LengthKm, JunctionFreeSection/Total_LengthKm);
					attribute<km>                              LengthKm                       := MakeDefined(Find_DuplicateLinks/min_length_km[Find_DuplicateLinks_rel],LengthKm_org);
					attribute<bool>                            IsOneDirection                 := union_data(., UnchangedLinkSet/IsOneDirection, JunctionFreeSection/IsOneDirection);
					
					attribute<bool>                            IsLinkWithDeadEnd              := (NodeSet/IsDeadEnd[F1] || NodeSet/IsDeadEnd[F2]) && !IsOD_connection_road;
					attribute<bool>                            IsLinkConnectedWithItself      := F1 == F2;
					attribute<bool>                            IsDuplicateLink                := Find_DuplicateLinks/IsDuplicateLink[Find_DuplicateLinks_rel] && id(.) != Find_DuplicateLinks/FirstLink[Find_DuplicateLinks_rel];
					
					attribute<bool>                            ToBeOmitted                    := (IsLinkWithDeadEnd || IsLinkConnectedWithItself || IsDuplicateLink) && !IsOneDirection;
					attribute<bool>                            IsOD_connection_road           := union_data(., UnchangedLinkSet/IsOD_connection_road, JunctionFreeSection/IsOD_connection_road);
					
					attribute<Nodeset_x_NodeSet>               Nodeset_x_NodeSet_rel          := combine_data(Nodeset_x_NodeSet, min_elem(F1, F2), max_elem(F1,F2));
					attribute<Find_DuplicateLinks>             Find_DuplicateLinks_rel        := rlookup(Nodeset_x_NodeSet_rel, Find_DuplicateLinks/values);
					
					attribute<IntermediateLinkSet> 			   ItmLinkSet_rel				  := invert(IntermediateLinkSet/org_rel);
					
					//After clean up, the reduced road could collapse into a road which is duplicate.
					unit<uint32> Find_DuplicateLinks := unique(Nodeset_x_NodeSet_rel)
					{
						attribute<uint32>                    count_occurence := pcount(Find_DuplicateLinks_rel);
						attribute<bool>                      IsDuplicateLink := count_occurence > 1;
						attribute<s_f>                       min_impedance   := min(../impedance_org, Find_DuplicateLinks_rel);
						attribute<km>                        min_length_km   := min(../LengthKm_org, Find_DuplicateLinks_rel);
						attribute<..>                        FirstLink       := first(id(..), Find_DuplicateLinks_rel);
					}
					
					//For visualisation
					attribute<BaseProjection_ip>                  FirstPoint                     := NodeSet/geometry[F1];
					attribute<BaseProjection_ip>                  LastPoint                      := NodeSet/geometry[F2];
					attribute<BaseProjection_ip>                  geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
					unit<uint32> PointSet := union_unit(.,.)
					{
						attribute<BaseProjection_ip>           Point   := Union_Data(., ../FirstPoint, ../LastPoint);
						attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
						attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
					}
				}
				
				//Verwijder links naar dead ends (if F1 or F2 occurs only once in all F1/F2, and not being OD-location)
				unit<uint32> IntermediateLinkSet := select_with_org_rel(!LinkSet_cleanedforJFS/ToBeOmitted)
				{
					//attribute<NodeSet> F1 := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/F1);
					//attribute<NodeSet> F2 := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/F2);
					attribute<NodeSet> F1:= org_rel -> F1;
					attribute<NodeSet> F2:= org_rel -> F2;
					
					attribute<s_f>     Impedance      := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/impedance);
					attribute<km>      LengthKm       := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/LengthKm);
					attribute<bool>    IsOneDirection := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/IsOneDirection);
					attribute<bool>    IsOD_connection_road       := collect_by_cond(., !LinkSet_cleanedforJFS/ToBeOmitted, LinkSet_cleanedforJFS/IsOD_connection_road);
					
					parameter<uint32>  count_arcs := #.;
					
					//For visualisation
					unit<uint32> PointSet := union_unit(.,.);
					attribute<BaseProjection_ip> geometry (arc) := points2sequence(Union_Data(PointSet, NodeSet/geometry[F1], NodeSet/geometry[F2]), value(id(PointSet) %#IntermediateLinkSet, IntermediateLinkSet));
				}
			}
		}
 	}
	
	Template Check_Connectiveness_T
	{
		unit<uint32> LinkSet_domain;
		unit<uint32> NodeSet_domain;
		attribute<NodeSet_domain> F1(LinkSet_domain);
		attribute<NodeSet_domain> F2(LinkSet_domain);
		///
		
		unit<uint32> Connected_Networks:= connected_parts(F1, F2) // Verzameling van alle netwerken, inclusief de subnetwerken.
		{
			attribute<uint32>   Nr_Nodes   := pcount(PartNr);
			parameter<Connected_Networks> Main       := max_index(Nr_Nodes); // uitgangspunt: het netwerk met de meeste nodes is het relevante netwerk
			attribute<bool>     IsConnected (NodeSet_domain) := PartNr == Main;
		}
		
		unit<uint32> reverse_directions:= select(!LinkSet_domain/IsOneDirection);
		
		// may require doubling of links with doubled directions...
		unit<uint32> LinkSet_digraph:= union_unit(LinkSet_domain, reverse_directions) {
			attribute<NodeSet_domain> F1:= union_data(., ../F1, collect_by_cond(reverse_directions, !LinkSet_domain/IsOneDirection, ../F2));
			attribute<NodeSet_domain> F2:= union_data(., ../F2, collect_by_cond(reverse_directions, !LinkSet_domain/IsOneDirection, ../F1));
		}
		
		unit<uint32> Strongly_connected_Networks:= strongly_connected_components(LinkSet_digraph/F1, LinkSet_digraph/F2) {
			attribute<uint32>   Nr_Nodes   := pcount(PartNr);
			parameter<Strongly_connected_Networks> Main       := max_index(Nr_Nodes); 
			attribute<bool>     IsConnected (NodeSet_domain) := PartNr == Main;
		}
		
		attribute<bool> IsVerbonden (LinkSet_domain) := Connected_Networks/IsConnected[F1] && Connected_Networks/IsConnected[F2];
		attribute<bool> IsSterkVerbonden (LinkSet_domain) := Strongly_connected_Networks/IsConnected[F1] && Strongly_connected_Networks/IsConnected[F2];
		
		attribute<bool>	NodesVerbonden (NodeSet_domain):= Connected_Networks/IsConnected;
		attribute<bool>	NodesSterkVerbonden (NodeSet_domain):= Strongly_connected_Networks/IsConnected;
		
		unit<uint32> NodesNotConnected := select_with_org_rel(!Connected_Networks/IsConnected)
		{
			attribute<BaseProjection>        geometry := org_rel -> geometry;
		}
		unit<uint32> NodesNotStronglyConnected := select_with_org_rel(!Strongly_connected_Networks/IsConnected)
		{
			attribute<BaseProjection>        geometry := org_rel -> geometry;
		}
	}
	
	Template Check_Connectiveness_T_adhoc
	{
		unit<uint32> LinkSet_domain;
		unit<uint32> NodeSet_domain;
		attribute<NodeSet_domain> F1(LinkSet_domain);
		attribute<NodeSet_domain> F2(LinkSet_domain);
		///
		
		attribute<bool>                      IsVerbonden  (LinkSet_domain) := Networks/IsConnected[F1] && Networks/IsConnected[F2];
		unit<uint32> Networks:= connected_parts(LinkSet_domain/F1, LinkSet_domain/F2) // Verzameling van alle netwerken, inclusief de subnetwerken.
		{
			attribute<uint32>   Nr_Nodes   := pcount(PartNr);
			parameter<Networks> Main       := max_index(Nr_Nodes); // uitgangspunt: het netwerk met de meeste nodes is het relevante netwerk
			attribute<bool>     IsConnected   (NodeSet_domain) := PartNr == Main;
		}

		unit<uint32> NodesNotConnected := select_with_org_rel(!Networks/Isconnected)
		{
			// attribute<BaseProjection> geometry := org_rel -> values;
		}
	}
}


