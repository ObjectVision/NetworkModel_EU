container Geography : using = "units"
{
	#include <ngr_layer_lea.dms>

	unit<dpoint> wgs84_base       : SpatialReference = "EPSG:4326";
	unit<dpoint> LambertEA        : SpatialReference = "EPSG:3035", DialogData = "ngr_layer_lea";
	unit<dpoint> WebMercator_base : SpatialReference = "EPSG:3857";
	unit<dpoint> rdc_meter_base   : SpatialReference = "EPSG:28992";
	unit<dpoint> BaseProjection    := LambertEA;
	unit<ipoint> BaseProjection_ip := gridset(BaseProjection, point_xy(1d, 1d), point_xy(0d, 0d), ipoint);
	
	unit<uint32> selection_polygon : nrofrows = 1, Using = "units"
	{
		container Extent_EU
		{
			//EU extent basemap
			parameter<float64> x_min :=  2300000d;
			parameter<float64> x_max :=  6500000d;
			parameter<float64> y_min :=  1300000d;
			parameter<float64> y_max :=  5500000d;
		}
		container Extent_Finland
		{
			//Extent North Finland
			parameter<float64> x_min :=  4700000d;
			parameter<float64> x_max :=  5300000d;
			parameter<float64> y_min :=  4700000d;
			parameter<float64> y_max :=  5230000d;
		}
		container Extent_Amsterdam
		{
			//Extent Amsterdam
			parameter<float64> x_min :=  3960000d;
			parameter<float64> x_max :=  3987000d;
			parameter<float64> y_min :=  3250000d;
			parameter<float64> y_max :=  3270000d;
		}
		container Extent_Netherlands
		{
			parameter<float64> x_min :=  3851000d;
			parameter<float64> x_max :=  4136000d;
			parameter<float64> y_min :=  3070000d;
			parameter<float64> y_max :=  3400000d;
		}
		
		container Extent := ='Extent_'+ModelParameters/CountryFolder;
		
		parameter<BaseProjection> top_left     := point_xy(Extent/x_min, Extent/y_max, BaseProjection); 
		parameter<BaseProjection> top_right    := point_xy(Extent/x_max, Extent/y_max, BaseProjection);
		parameter<BaseProjection> bottom_left  := point_xy(Extent/x_min, Extent/y_min, BaseProjection);
		parameter<BaseProjection> bottom_right := point_xy(Extent/x_max, Extent/y_min, BaseProjection);
		
		unit<uint32> point_set : nrofrows = 5
		{
			attribute<BaseProjection>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
			attribute<..>              sequence_rel := const(0, .);
			attribute<.>               ordinal      := id(.);
		}
		
		attribute<BaseProjection> geometry (poly)      := points2sequence(point_set/point, point_set/sequence_rel, point_set/ordinal);
		
		unit<uint32> result := selection_polygon;
	}
	
	unit<ipoint> Base_grid_1km       := SourceData/Locations/Population, DialogData = "BaseProjection"
	{
		attribute<Base_grid_5km>      grid_5k_rel    := id(.)[Base_grid_5km];
		attribute<Base_grid_10km>     grid_10k_rel   := id(.)[Base_grid_10km];
		attribute<Base_grid_50km>     grid_50k_rel   := id(.)[Base_grid_50km];
		attribute<.>                  id             := id(.);
		parameter<BaseProjection>     center_delta   := point_xy(0.5d * 1000d, -0.5d * 1000d, BaseProjection);
		attribute<BaseProjection>     point          := id[BaseProjection] + center_delta;
		attribute<bool>               IsEU           := IsDefined(point_in_polygon(point, SourceData/RegionalUnits/NUTS/geometry));
		//attribute<bool>				  IsEFTA		 := 
		attribute<SourceData/RegionalUnits/Country/subset> Country_rel:= point_in_polygon(point, SourceData/RegionalUnits/Country/subset/geometry);
		attribute<bool>               IsCountry      := IsDefined(Country_rel);
		attribute<uint32>             Population     := SourceData/Locations/Population/ReadData[uint32];
		
		
		attribute<Base_grid_1km_spoint> Base_grid_1km_spoint_rel     := point[Base_grid_1km_spoint];
		attribute<bool>                 Select_criterium             := =ModelParameters/Use_Country_OD_selection ? 'isDefined(id) && IsCountry' : 'isDefined(id) && IsEU';
		
		unit<uint32>                    id_key           := range(uint32, 0, uint32(#.));
		attribute<uint32>               id_rel           := value(uint32(pointrow(id(.))) * uint32(nr_cols) + uint32(pointcol(id(.))), id_key);
			
		parameter<int32> nr_cols := int32(max(pointcol(id(.))) - min(pointcol(id(.))));
		parameter<int32> nr_rows := int32(max(pointrow(id(.))) - min(pointrow(id(.))));
			
		unit<uint32> points := select_uint32(Select_criterium)
		{
			attribute<BaseProjection>       geometry          := collect_by_cond(., ../Select_criterium, ../point);
			attribute<..>                   Base_grid_rel     := geometry[..];
			attribute<SourceData/RegionalUnits/Country/subset> Country_rel:= collect_by_cond(., ../Select_criterium, ../Country_rel);
			attribute<Base_grid_1km_spoint> Base_grid_1km_spoint_rel := collect_by_cond(., ../Select_criterium, ../Base_grid_1km_spoint_rel); 
			attribute<ipoint>               id                := collect_by_cond(., ../Select_criterium, ../id);
			
			attribute<float64>              x                 := PointCol(geometry);
			attribute<float64>              y                 := PointRow(geometry);
			
			attribute<..>                   grid_domain_rel   := geometry[..];
			attribute<uint32>               Population        := collect_by_cond(., ../Select_criterium, ../Population);
			attribute<uint32>               id_rel            := collect_by_cond(., ../Select_criterium, ../id_rel);
		}
	}
	unit<spoint> Base_grid_1km_spoint  := gridset(
												 BaseProjection                         // the baseunit in which the coordinates of the coordinate system are expressed;
												,GetProjectionFactor(Base_grid_1km)     // the size of the grid cells in both X and Y directions, expressed in the base unit;
												,GetProjectionOffSet(Base_grid_1km)     // the offset, the coordinates of the top left coordinate, expressed in the base unit;
												,spoint                                 // the value type of the resulting domain unit (in earlier versions the value type was configured as string, this is not supported anymore)
											);
	
	unit<ipoint> Base_grid_5km   := Get_grid_5km/Base_grid;
	unit<ipoint> Base_grid_10km  := Get_grid_10km/Base_grid;
	unit<ipoint> Base_grid_50km  := Get_grid_50km/Base_grid;

	container Get_grid_5km  := GetGrid_T(5);
	container Get_grid_10km := GetGrid_T(10);
	container Get_grid_50km := GetGrid_T(50);
	
	Template GetGrid_T
	{
		parameter<uint32> Gridsize;
		////
		unit<dpoint> proto_base_grid  := gridset(
												 BaseProjection                                                         // the baseunit in which the coordinates of the coordinate system are expressed;
												,GetProjectionFactor(Base_grid_1km) * point_xy(Gridsize[float64], Gridsize[float64], BaseProjection)     // the size of the grid cells in both X and Y directions, expressed in the base unit;
												,GetProjectionOffSet(Base_grid_1km)                                     // the offset, the coordinates of the top left coordinate, expressed in the base unit;
												,BaseProjection                                                         // the value type of the resulting domain unit (in earlier versions the value type was configured as string, this is not supported anymore)
											);
		
		unit<ipoint> Base_grid  := range(proto_base_grid, point_xy(0i,0i,ipoint), (upperbound(Base_grid_1km) + point_xy(Gridsize[int32] - 1i, Gridsize[int32] -1i)) / point_xy(Gridsize[int32],Gridsize[int32],ipoint) ), DialogData = "BaseProjection"
		{
			attribute<int32>            rownr            := pointRow(id(.));
			attribute<bool>             uneven           := mod(rownr, 2i) > 0i;
			attribute<BaseProjection>   point            := mapping(Base_grid, BaseProjection) + point_xy(0.5d * Gridsize[float64] * 1000d, -0.5d * Gridsize[float64] * 1000d, BaseProjection);
			attribute<Base_grid_1km_spoint> Base_grid_1km_spoint_rel     := point[Base_grid_1km_spoint];
			attribute<.>                Base_grid_rel    := point[.];
			attribute<bool>             IsEU             := IsDefined(point_in_polygon(point, SourceData/RegionalUnits/NUTS/geometry));
			attribute<bool>             IsCountry        := IsDefined(point_in_polygon(point, SourceData/RegionalUnits/Country/subset/geometry));
			attribute<bool>             IsCountryBuffer  := ='IsDefined(point_in_polygon(point, geos_buffer_multi_polygon(SourceData/RegionalUnits/Country/subset/geometry, '+string(/ModelParameters/Org_Gridsize)+'000[m], 16b)))';
			attribute<uint32>           Population       := ='sum_uint32(SourceData/Locations/Population/ReadData, Base_grid_1km/grid_'+string(Gridsize)+'k_rel)';
			attribute<float32>          LocalPotential   := ='potential(Population[float64], Geography/Distmatrices/Impl/pot5000m/potRange/rev_dist_scaled)[float32]';

			attribute<bool>             Select_criterium := =ModelParameters/Use_Country_OD_selection ? 'IsCountryBuffer' : 'IsEU';
			
			unit<uint32>                id_key           := range(uint32, 0, uint32(#.));
			attribute<uint32>           id_rel           := value(uint32(pointrow(id(.))) * uint32(nr_cols) + uint32(pointcol(id(.))), id_key);
			
			parameter<int32> nr_cols := int32(max(pointcol(id(.))) - min(pointcol(id(.))));
			parameter<int32> nr_rows := int32(max(pointrow(id(.))) - min(pointrow(id(.))));
			
			unit<uint32> points := select_uint32(Select_criterium)
			{
				attribute<BaseProjection>       geometry                 := collect_by_cond(., ../Select_criterium, ../point);
				attribute<Base_grid_1km_spoint> Base_grid_1km_spoint_rel := collect_by_cond(., ../Select_criterium, ../Base_grid_1km_spoint_rel); 
				attribute<Base_grid>            Base_grid_rel            := collect_by_cond(., ../Select_criterium, ../Base_grid_rel); 
				attribute<float64>              x                        := PointCol(geometry);
				attribute<float64>              y                        := PointRow(geometry);
				attribute<..>                   grid_domain_rel          := geometry[..];	
				attribute<uint32>               Population               := collect_by_cond(., ../Select_criterium, ../Population);
				attribute<float32>              LocalPopulation          := collect_by_cond(., ../Select_criterium, ../LocalPotential);
				attribute<uint32>               id_rel                   := collect_by_cond(., ../Select_criterium, ../id_rel);
			}
		}
	}
	
	container Distmatrices 
	{
		unit<UInt8> Matrix : NrOfRows = 7
		, Descr = "Bevat de verschillende afstandsmatrices die gebruikt kunnen worden in het model."
		{
			attribute<m>   size : [ 1000, 2000, 2500, 5000, 10000, 20000, 50000];
			attribute<String>  name := 'pot'+string(size)+'m';
		}
		unit<UInt32> Dist2Range;
		
		container Impl  := for_each_ne(Matrix/name, 'PotRange('+string(ModelParameters/Org_Gridsize)+'000[m],'+string(Matrix/size)+'[m])');
		
		template PotRange
		{
			parameter<m>   gridgrootte;
			parameter<m>   afkapstraal;
			///
			parameter<Float64> straal  := afkapstraal / gridgrootte;
			parameter<Float64> oppervlakte  := pi() * straal^2d;
			
			unit<SPoint> tmpRange:= range(spoint, point_yx(-int16(straal), -int16(straal)), point_yx(int16(straal) + 1s, int16(straal) + 1s));
			unit<SPoint> PotRange:= tmpRange // TODO 2017-09-26: remove indirection & clean-up
			{
				attribute<Dist2Range> distMatr := dist2(point_yx(0s, 0s, tmpRange), Dist2Range);
				attribute<Float64> dist := sqrt(Float64(distMatr));
				attribute<Float64> dist_scaled := dist / straal;
				
				attribute<Float64> rev_dist        := max_elem(straal - dist, 0d);
				parameter<Float64> rev_dist_max    := max(rev_dist);
				attribute<Float64> rev_dist_scaled := rev_dist / rev_dist_max;
				attribute<Float64> AbsWeight :=
					distMatr[Float64] <= (straal * straal) ?
						distMatr[Float64] != 0f ?
							1f / (distMatr[Float64] ^ 2f) :
							1f :
						0f;
				
				attribute<Float64> AbsWeight_ln :=
					distMatr[Float64] <= (straal * straal) ?
						distMatr[Float64] != 0f ?
							1f / (distMatr[Float64] / straal) :
							1f :
						0f;
				
				attribute<Float64> RelWeight         := scalesum(     AbsWeight , 1.0f );
				attribute<Float64> RelWeightSqrt     := scalesum(Sqrt(AbsWeight), 1.0f );
				attribute<Float64> Flat2             := float32(distMatr <= uint32(straal * straal));
				attribute<Float64> Flat_Visualisatie := dist <= 1.5f ? 1f : 0f;
				attribute<Float64> neighbourhood     := distMatr > 0 ? 1f : 0f;
				parameter<Float64> oppervlakte     := sum(Flat2);
				attribute<Float64> binair          := distMatr <= 100 ? 1f : 0f;
			}
		}
	
		
		
		container Distmatrices_25m  := for_each_nex(Matrix/name, 'Distmatrices/Impl_25m/'+Matrix/name+'/PotRange', spoint), Descr = "Bevat de verschillende afstandsmatrices die gebruikt kunnen worden in het model, op basis van een grid van 25m.";
		
	}
}
