container ComputeProxy: Using = "Units;geometries;SourceData;"
{
	parameter<s_f>     MaxTraveltime := (30[min_f])[s_f];
	parameter<km>      Self_Distance := 0.23[km]; //de theoretische gemiddelde 0.23 km die je moet reizen om een random bestemming binnen je eigen 1km grid cel te bereiken. Volgens Lewis.
	
	parameter<string>  smax_time     := replace(string(MaxTraveltime), '.', '_');
	parameter<km>      maxWalkDist   := 1.001[km];
	parameter<km>      maxCycleDist  := 3.001[km];
	
	unit<uint32> FinalLinkSet := NetworkSetup/Base_Analysis/NetwerkSpec/CreateMoreEfficientNetwork/FinalLinkSet;
	unit<uint32> FinalNodeSet := NetworkSetup/Base_Analysis/NetwerkSpec/CreateMoreEfficientNetwork/FinalNodeSet;
	unit<uint32> OD_points    := NetworkSetup/Base_Analysis/NetwerkSpec/UniqueLocations;
	unit<ipoint> Base_grid    := = 'Geometries/Base_grid_'+ModelParameters/OrgGridsize;
	unit<uint32> Origins      := NetworkSetup/Base_Analysis/NetwerkSpec/OrgDomain;
	unit<uint32> Destinations := NetworkSetup/Base_Analysis/NetwerkSpec/DestDomain;
	
	unit<uint32> distdecay_functions: NrOfRows = 6 
	{
		attribute<string> LabelText: ['Geurs_VanEck_2003_general', 'logistic_steep', 'logistic_slight', 'Power_m10', 'Power_m15', 'Power_m20'];
		attribute<string> eval: ['1d / (1d + exp(-6.899d + (2.326d * log(Mij))))', '1d / (1d + exp(-4d + (2.337666667d * log(Mij)[float64]))[float64])','1d / (1d + exp(-8d + (2.337666667d * log(Mij)[float64]))[float64])', '(Mij^-1d)[float64]', '(Mij^-1.5d)[float64]', '(Mij^-2d)[float64]'];
	}
	
	unit<uint64> Matrix :=
		dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);alternative(link_imp):alt_imp;od:OrgZone_rel,DstZone_rel,impedance'
			, FinalLinkSet/impedance
			, FinalLinkSet/F1
			, FinalLinkSet/F2
			///
			, !FinalLinkSet/IsOneDirection
			, FinalNodeSet/OrgNode_rel
			, FinalNodeSet/DestNode_rel
			, MaxTraveltime
			, FinalLinkSet/LengthKm
		)
	{
		attribute<min_f>        Minutes  := impedance[min_f];
		attribute<Origins>      i        := OrgZone_rel; //origin id
		attribute<Destinations> j        := DstZone_rel; //destination id
		attribute<bool>         self     := Origins/id_rel[i] = Destinations/id_rel[j]; //Is OD-pair pair of itself
		attribute<uint32>       Pi       := Origins/Population[i];  //Population in origin
		attribute<uint32>       Pj       := Destinations/Population[j]; //Population in destination
		attribute<min_f>        Mij      := self ? convert(Self_Distance / ModelParameters/Advanced/CarDefaultSpeed_low, min_f) : Minutes;
		attribute<km>           Net_Dij  := self ? Self_Distance : alt_imp;
		attribute<km>           EUCL_Dij := self ? Self_Distance : dist(Origins/geometry[i], Destinations/geometry[j])[km];
	}	
	
	container Results_per_distdecay:= 
		for_each_ne(
			distdecay_functions/LabelText
			, 'comp_results(Matrix, '+string(id(distdecay_functions))+'[distdecay_functions])'
		) 
	{
		container collect 
		{
			parameter<bool> Button:= True, explicitsuppliers = "= AsList(distdecay_functions/LabelText+'/StoreOriginResults', ';') + ';' + AsList(distdecay_functions/LabelText+'/StoreDestinationResults', ';') ";
		}
	}
	
	Template doMergeProxies 
	{
		parameter<distdecay_functions> infunc;
		
		unit<uint32> mergeProxy:= = 'union_unit(Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points)'
		, DialogData = "point"
		, DialogType = "map"
		, storagename = "='%LocalDataProjDir%/travel_proxy/mozaiks/'+distdecay_functions/LabelText[infunc]+'.dbf'"
		{
			attribute<LambertEA> point   := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/point)', storagename = "= '%LocalDataProjDir%/travel_proxy/mozaiks/'+distdecay_functions/LabelText[infunc]+'.shp'";
			attribute<float32>   Pop     := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/org_pop)';
			attribute<float32>   Ai      := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/Ai)';
			attribute<float32>   avnetdi := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/avnetdi)';
			attribute<float32>   aveucdi := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/aveucdi)';
			attribute<float32>   avtimei := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/avtimei)';
		}
	}
	
	container MergeProxies:= 
		for_each_ne(
			distdecay_functions/LabelText
			, 'doMergeProxies('+string(id(distdecay_functions))+')'
		) 
	{
		container collect 
		{
			parameter<bool> Button:= True, ExplicitSuppliers = "= AsList(distdecay_functions/LabelText+'/mergeProxy',';')";
		}
	}
	
	

	
	Template comp_results 
	{
		unit<uint64> inMatrix;
		parameter<distdecay_functions> infunc;
		
		unit<uint64> Matrix:= inMatrix 
		{
			attribute<min_f>   Fij               := = distdecay_functions/eval[infunc];             // decayed traveltime from origin to destination
			attribute<float64> Ai (Origins)      := sum(Pj[float64] * Fij, i);                      // decayed reachable destination population in origin
			attribute<float64> Aj (Destinations) := sum(Pi[float64] * Fij, j);                      // decayed reachable origin population in destination
			attribute<float64> Tij               := (1d / Ai[i]) * Pi[float64] * Pj[float64] * Fij; // Modelled traveltime between origin and destination
			attribute<float64> WALKij            := float64(Net_Dij < maxWalkDist);                 // is network distance walkable?
			attribute<float64> CYCLij            := float64(Net_Dij < maxCycleDist);                // is network distance bikeable?
		}
		
		unit<uint32> PerOrigin := Origins
		{
			attribute<min_f>   AvgTime         := sum(Matrix/Tij * Matrix/Mij, Matrix/i);
			attribute<km>      AvgNetDistance  := sum(Matrix/Tij * Matrix/Net_Dij, Matrix/i);
			attribute<km>      AvgEUCLDistance := sum(Matrix/Tij * Matrix/Net_Dij, Matrix/i);
			attribute<float64> ACCi            := Matrix/Ai;
			attribute<km>      max_Net_Di      := max(Matrix/Net_Dij, Matrix/i);
			attribute<km>      max_EUCL_Di     := max(Matrix/EUCL_Dij, Matrix/i);
			attribute<min_f>   PotWalk         := sum(Matrix/Tij * Matrix/WALKij, Matrix/i);
			attribute<min_f>   PotCycle        := sum(Matrix/Tij * Matrix/CYCLij, Matrix/i);
		}
		
		unit<uint32> PerDestination: expr = "Destinations" 
		{
			attribute<float64> visits:			expr = "sum(Matrix/Tij, Matrix/j)";
			attribute<float64> ACCj:			expr = "Matrix/Aj";
			attribute<float64> AvgTime: 		expr = "sum(Matrix/Tij * Matrix/Mij, Matrix/j) / visits";
			attribute<float64> AvgNetDistance:	expr = "sum(Matrix/Tij * Matrix/Net_Dij, Matrix/j) / visits";
		}
		
		unit<uint32> StoreOriginResults:= PerOrigin, storagename = "= '%LocalDataProjDir%/travel_proxy/region_origin_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.dbf'" 
		{
			attribute<uint32> 	orgid:= PerOrigin/orgid;
			attribute<float64>	ai:= ACCi;
			attribute<float64> 	avtime:= AvgTime;
			attribute<float64>	avnetd:= AvgNetDistance;
			attribute<float64>	aveucd:= AvgEUCLDistance;
			attribute<float64>	fracwalk:= PotWalk;
			attribute<float64>	fraccycle:= PotCycle;
		}
		
		unit<uint32> StoreDestinationResults:= PerDestination, storagename = "= '%LocalDataProjDir%/travel_proxy/region_destination_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.dbf'" 
		{
			attribute<uint32> 	orgid:= PerDestination/orgid;
			attribute<float32>	aj:= ACCj;
			attribute<float32> 	avtime:= AvgTime;
			attribute<float32>	avnetd:= AvgNetDistance;
			attribute<float32>	visits:= PerDestination/visits;
			attribute<float32> 	attract:= PerDestination/Pop;
		}
		
		unit<uint32> Origin_Results_ReadOnly: storagename = "= propvalue(StoreOriginResults, 'storagename')", storagereadonly = "True";
		unit<uint32> Destination_Results_ReadOnly: storagename = "= propvalue(StoreDestinationResults, 'storagename')", storagereadonly = "True";
		
		unit<uint32> revert_to_od_points:= OD_points 
		{
			attribute<Origin_Results_ReadOnly> or_id:= invert(Origin_Results_ReadOnly/orgid[OD_points]);
			attribute<Destination_Results_ReadOnly> dr_id:= invert(Destination_Results_ReadOnly/orgid[OD_points]);
			attribute<float32> 	ai:= 		MakeDefined(float32(Origin_Results_ReadOnly/ai[or_id]), 0f);
			attribute<float32> 	avtimei:= 	MakeDefined(float32(Origin_Results_ReadOnly/avtime[or_id]) / org_pop, 0f);
			attribute<float32> 	avnetdi:= 	MakeDefined(float32(Origin_Results_ReadOnly/avnetd[or_id]) / org_pop, 0f);
			attribute<float32> 	aveucdi:= 	MakeDefined(float32(Origin_Results_ReadOnly/aveucd[or_id]) / org_pop, 0f);
			attribute<float32> 	avtimej:= 	MakeDefined(float32(Destination_Results_ReadOnly/avtime[dr_id]) / org_pop, 0f);
			attribute<float32> 	avnetdj:= 	MakeDefined(float32(Destination_Results_ReadOnly/avnetd[dr_id]) / org_pop, 0f);
			attribute<float32> 	fracwalki:= MakeDefined(float32(Origin_Results_ReadOnly/fracwalk[or_id]) / org_pop, 0f);
			attribute<float32> 	fracyclei:= MakeDefined(float32(Origin_Results_ReadOnly/fraccycle[or_id]) / org_pop, 0f);
		}
	}
	
	// Template collectresultsT 
	// {
		// parameter<distdecay_functions> infunc;
		
		// unit<uint32> collectresults:= = 'union_unit(Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points)'
		// , DialogData  = "point"
		// , DialogType  = "map"
		// , storagename = "= '%LocalDataProjDir%/travel_proxy/mozaik/'+distdecay_functions/LabelText[infunc]+'.dbf'"
		// {
			// attribute<LambertEA> point: 	 = = 'union_data(., '+ AsItemList('AnalysisPerRegion//Origins/point') +')'", StorageName = "= '%ProjDir%/results/points_'+ ZoneName +'_'+ spopsource +'_'+ sdistdecay +'.shp'";
			// attribute<float32> Avd: 		 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/PerOrigin/AvgDistance') +')'";
			// attribute<float32> Pop: 		 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/Origins/Pop') +')'";
			// attribute<float32> Ai: 			 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/Origins/Ai') +')'";
			// attribute<float32> MaxDi:		 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/PerOrigin/maxDi') +')'";
			// attribute<float32> PotWalk:		 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/PerOrigin/PotWalk') +')'";
			// attribute<float32> PotCycle:	 = = 'union_data(., '+ AsItemList('AnalysisPerRegion/'+ RegionNetworkSet/OriginsAndDestinations/selRegions/Nuts_Code +'/PerOrigin/PotCycle') +')'";
			// attribute<float32> PopDist:		 = Pop * Avd";
		// }
	// }
}