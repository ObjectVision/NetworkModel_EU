container ComputeProxy: Using = "Units;geometries;SourceData;"
{
	parameter<s_f>     MaxTraveltime := (60[min_f])[s_f];
	parameter<min_f>   Int_time		 := convert(Self_Distance / ModelParameters/Advanced/CarDefaultSpeed_low, min_f);
	parameter<km>      Self_Distance := 0.23[km]; //de theoretische gemiddelde 0.23 km die je moet reizen om een random bestemming binnen je eigen 1km grid cel te bereiken. Volgens Lewis.
	parameter<km>      maxWalkDist   := 1.001[km];
	parameter<km>      maxCycleDist  := 3.001[km];
	
	unit<uint32>       FinalLinkSet  := NetworkSetup/Base_Analysis/NetwerkSpec/CreateMoreEfficientNetwork/FinalLinkSet;
	unit<uint32>       FinalNodeSet  := NetworkSetup/Base_Analysis/NetwerkSpec/CreateMoreEfficientNetwork/FinalNodeSet;
	unit<uint32>       OD_points     := NetworkSetup/Base_Analysis/NetwerkSpec/DestDomain;
	
	container RunPerMS:= for_each_ne(RegionalUnits/EUplus/CNTR_ID, 'CalcPerMs_T(RegionalUnits/EUplus/Geometry['+string(id(RegionalUnits/EUplus))+'], FinalLinkSet/Minutes_weekday_0830, Int_time[float64])');
	
	
	Template CalcPerMs_T {
		parameter<LambertEA> inZone (polygon);
		attribute<float64> alt_imp (FinalLinkSet);
		parameter<float64> alt_imp_self;
		
		parameter<string> alt_imp_expr:= propvalue(alt_imp, 'Expr');
		parameter<string> alt_imp_def:= substr(alt_imp_expr, strpos(alt_imp_expr, '/')+1, strlen(alt_imp_expr)); //isolates name of attribute that is being requested as alternative impedance
		
		parameter<string> zonename:= propvalue(., 'Name');
		
		attribute<bool> OD_points_in_zone (OD_points):= point_in_polygon(OD_points/Geometry, inZone);
		
		unit<uint32> sel_od_points:= subset(OD_points_in_zone) {
			attribute<LambertEA> Geometry:= OD_points/Geometry[Nr_OrgEntity];
			attribute<uint32> pop:= OD_points/population[Nr_OrgEntity];
			attribute<FinalNodeSet> node_rel:= FinalNodeSet/DestNode_rel[Nr_OrgEntity];
		}
		unit<uint32> Origins:= sel_od_points;
		unit<uint32> Destinations:= sel_od_points;
		
		unit<uint64> Matrix :=
		dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);alternative(link_imp):alt_imp;od:OrgZone_rel,DstZone_rel,impedance'
			, FinalLinkSet/impedance
			, FinalLinkSet/F1
			, FinalLinkSet/F2
			///
			, !FinalLinkSet/IsOneDirection
			, sel_od_points/node_rel
			, sel_od_points/node_rel
			, MaxTraveltime
			, alt_imp
		)
		{
			attribute<min_f>        Minutes  := impedance[min_f];
			attribute<sel_od_points>i        := OrgZone_rel; //origin id
			attribute<sel_od_points>j        := DstZone_rel; //destination id
			attribute<bool>         self     := i == j; //Is OD-pair pair of itself
			attribute<float64>      Pi       := float64(sel_od_points/pop)[i];  //Population in origin
			attribute<float64>      Pj       := float64(sel_od_points/pop)[j]; //Population in destination
			attribute<min_f>        Mij      := self ? Int_time : Minutes;
			attribute<float64>      Alt_Dij  := self ? alt_imp_self : alt_imp;
			attribute<km>           EUCL_Dij := self ? Self_Distance : dist(sel_od_points/geometry[i], sel_od_points/geometry[j])[km];
		}
		
		container Results_per_distdecay:= 
		for_each_ne(
			distdecay_functions/LabelText
			, 'comp_results_T(Matrix, '+string(id(distdecay_functions))+'[distdecay_functions])'
		) ;
	
			
	}
	
	
	
	
	
	
	
	Template comp_results_T {
		unit<uint64> inMatrix;
		parameter<distdecay_functions> infunc;
		
		unit<uint64> Matrix:= inMatrix {
			attribute<float64>		Fij: 	expr = "= distdecay_functions/eval[infunc]";
			attribute<float64>		Ai (Origins):= sum(Pj * Fij, i);
			attribute<float64>		Aj (Destinations):= sum(Pi * Fij, j);
			attribute<float64>		Tij:	expr = "(1d / Ai[i]) * Pi * Pj * Fij";
			attribute<float64>		WALKij:	expr = "float64(Alt_Dij[km] < maxWalkDist)";
			attribute<float64>		CYCLij:	expr = "float64(Alt_Dij[km] < maxCycleDist)";
		}
		unit<uint32> PerOrigin: expr = "Origins"
		{
			attribute<float64> AvgTime: 		expr = "sum(Matrix/Tij * Matrix/Mij, Matrix/i)";
			attribute<float64> AvgAltImp: 		expr = "sum(Matrix/Tij * Matrix/Alt_Dij, Matrix/i)";
			attribute<float64> AvgEUCLDistance: expr = "sum(Matrix/Tij * Matrix/EUCL_Dij, Matrix/i)";
			attribute<float64> ACCi:			expr = "Matrix/Ai";
			attribute<float64> max_Net_Di:		expr = "max(Matrix/Alt_Dij, Matrix/i)";
			attribute<float64> max_EUCL_Di:		expr = "max(Matrix/EUCL_Dij, Matrix/i)";
			attribute<float64> PotWalk:			expr = "sum(Matrix/Tij * Matrix/WALKij, Matrix/i)";
			attribute<float64> PotCycle:		expr = "sum(Matrix/Tij * Matrix/CYCLij, Matrix/i)";
		}
		unit<uint32> PerDestination: expr = "Destinations" {
			attribute<float64> visits:			expr = "sum(Matrix/Tij, Matrix/j)";
			attribute<float64> ACCj:			expr = "Matrix/Aj";
			attribute<float64> AvgTime: 		expr = "sum(Matrix/Tij * Matrix/Mij, Matrix/j) / visits";
			attribute<float64> AvgAltImp:		expr = "sum(Matrix/Tij * Matrix/Alt_Dij, Matrix/j) / visits";
		}
		unit<uint32> StoreOriginResults:= PerOrigin, storagename = "= '%LocalDataProjDir%/travel_proxy/region_origin_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.dbf'" {
			attribute<LambertEA>Geometry:= PerOrigin/Geometry, storagename = "= '%LocalDataProjDir%/travel_proxy/region_origin_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.shp'";
			attribute<uint32> 	orgid:= PerOrigin/Nr_OrgEntity;
			attribute<float64>	ai:= ACCi;
			attribute<float64> 	avtime:= AvgTime;
			attribute<float64>	avaltimp:= AvgAltImp;
			attribute<float64>	aveucd:= AvgEUCLDistance;
			attribute<float64> 	trips:= float64(Pop);
			//attribute<float64>	fracwalk:= PotWalk;
			//attribute<float64>	fraccycle:= PotCycle;
		}
		unit<uint32> StoreDestinationResults:= PerDestination, storagename = "= '%LocalDataProjDir%/travel_proxy/region_destination_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.dbf'" {
			attribute<LambertEA>Geometry:= PerDestination/Geometry, storagename = "= '%LocalDataProjDir%/travel_proxy/region_destination_results/'+ZoneName+'/'+distdecay_functions/LabelText[infunc]+'.shp'";
			attribute<uint32> 	orgid:= PerDestination/Nr_OrgEntity;
			attribute<float64>	aj:= ACCj;
			attribute<float64> 	avtime:= AvgTime;
			attribute<float64>	avaltimp:= AvgAltImp;
			attribute<float64>	visits:= PerDestination/visits;
			attribute<float64> 	attract:= float64(PerDestination/Pop);
		}
		unit<uint32> Origin_Results_ReadOnly: storagename = "= propvalue(StoreOriginResults, 'storagename')", storagereadonly = "True";
		unit<uint32> Destination_Results_ReadOnly: storagename = "= propvalue(StoreDestinationResults, 'storagename')", storagereadonly = "True";
		
		unit<uint32> revert_to_od_points:= all_od_points {
			attribute<Origin_Results_ReadOnly> or_id:= invert(Origin_Results_ReadOnly/orgid[all_od_points]);
			attribute<Destination_Results_ReadOnly> dr_id:= invert(Destination_Results_ReadOnly/orgid[all_od_points]);
			attribute<float64> 	ai:= 		MakeDefined(float64(Origin_Results_ReadOnly/ai[or_id]), 0f);
			attribute<float64> 	avtimei:= 	MakeDefined(float64(Origin_Results_ReadOnly/avtime[or_id]) / org_pop, 0f);
			attribute<float64> 	avnetdi:= 	MakeDefined(float64(Origin_Results_ReadOnly/avnetd[or_id]) / org_pop, 0f);
			attribute<float64> 	aveucdi:= 	MakeDefined(float64(Origin_Results_ReadOnly/aveucd[or_id]) / org_pop, 0f);
			attribute<float64> 	avtimej:= 	MakeDefined(float64(Destination_Results_ReadOnly/avtime[dr_id]) / org_pop, 0f);
			attribute<float64> 	avnetdj:= 	MakeDefined(float64(Destination_Results_ReadOnly/avnetd[dr_id]) / org_pop, 0f);
			attribute<float64> 	fracwalki:= MakeDefined(float64(Origin_Results_ReadOnly/fracwalk[or_id]) / org_pop, 0f);
			attribute<float64> 	fracyclei:= MakeDefined(float64(Origin_Results_ReadOnly/fraccycle[or_id]) / org_pop, 0f);
		}
		
	}
	
		
	/// =================================
	/// ====== EXPORT ============
	/// =================================

	container Exports
	{
		attribute<float32float32>   Population      (OD_points) := OD_points/Population;
		attribute<Origins>   origin_id       (OD_points) := rlookup(OD_points/OrgDomain_rel, value(Origins/orgid, uint32));
		
		attribute<float32>   D_i             (OD_points) := MakeDefined(float32(Matrix/D_i[origin_id]), 0f);
		
		attribute<km>        AvgNetDistance    (Origins) := sum(Matrix/Tij * Matrix/Net_d_ij, Matrix/i);
		attribute<float32>   avnetdi         (OD_points) := MakeDefined(float32(AvgNetDistance[origin_id]) / Population[float32], 0f);
		
		attribute<km>        AvgEUCLDistance   (Origins) := sum(Matrix/Tij * Matrix/EUCL_d_ij, Matrix/i);
		attribute<float32>   aveucdi         (OD_points) := MakeDefined(float32(AvgEUCLDistance[origin_id]) / Population[float32], 0f);
		
		attribute<min_f>     AvgTime           (Origins) := sum(Matrix/Tij * Matrix/d_ij, Matrix/i)[min_f];
		attribute<float32>   avtimei         (OD_points) := MakeDefined(float32(AvgTime[origin_id]) / Population[float32], 0f);
	}
	
	unit<uint32> distdecay_functions:= subset(id(distdecay_functions_all) < 2) {
		attribute<string> LabelText:= distdecay_functions_all/LabelText[Nr_OrgEntity];
		attribute<string> eval:= distdecay_functions_all/eval[Nr_OrgEntity];
	}
	
	unit<uint32> distdecay_functions_all: NrOfRows = 6 
	{
		attribute<string> LabelText : 	['Geurs_VanEck_2003_general'
											, 'logistic_steep'
											, 'logistic_slight'
											, 'Power_m10'
											, 'Power_m15'
											, 'Power_m20'
										];
		attribute<string> eval      : 	['(1d / (1d + exp(-6.899d + (2.326d * log(Mij)))))[min_f]'
											, '(1d / (1d + exp(-5.35d + (2.337666667d * log(Mij)))))[min_f]'
											, '(1d / (1d + exp(-7.95d + (2.337666667d * log(Mij)))))[min_f]'
											, '(Mij^-1d)[min_f]'
											, '(Mij^-1.5d)[min_f]'
											, '(Mij^-2d)[min_f]'
										];
		attribute<float64>    alpha     :	[ -6.899
											,-4
											, -8
											, 0
											, 0
											, 0
										];
		attribute<float64>    beta      :	[ 2.326
											, 2.337666667
											, 2.337666667
											, 0
											, 0
											, 0
										];
		attribute<float64>    gamma      :	[ 0
											, 0
											, 0
											, 0
											, 0
											, 0
										];
		attribute<float64>    γ          :	[ 0
											, 0
											, 0
											, -1
											, -1.5
											, -2
										];
		attribute<bool>    IsLogLogisticDecay :	[ TRUE
											, TRUE
											, TRUE
											, FALSE
											, FALSE
											, FALSE
										];
										
						
	}
	
	
	
	
	
	
	// Template Compute_Results_T
	// {
		// unit<uint64> inMatrix;
		// parameter<distdecay_functions> infunc;
		
		// unit<uint64> Matrix:= inMatrix 
		// {
			// attribute<min_f>   Fij               := = distdecay_functions/eval[infunc];             // decayed traveltime from origin to destination
			// attribute<float64> Ai (Origins)      := sum(Pj[float64] * Fij, i);                      // potential accessibility to destination population
			// attribute<float64> Aj (Destinations) := sum(Pi[float64] * Fij, j);                      // potential accessibility to origin population
			// attribute<float64> Tij               := (1d / Ai[i]) * Pi[float64] * Pj[float64] * Fij; // Estimated number of trips from i to j
			// attribute<float64> WALKij            := float64(Net_Dij < maxWalkDist);                 // is network distance walkable?
			// attribute<float64> CYCLij            := float64(Net_Dij < maxCycleDist);                // is network distance bikeable?
		// }
		
		// unit<uint32> PerOrigin := Origins
		// {
			// attribute<min_f>   AvgTime         := sum(Matrix/Tij * Matrix/Mij, Matrix/i)[min_f];
			// attribute<km>      AvgNetDistance  := sum(Matrix/Tij * Matrix/Net_Dij, Matrix/i);
			// attribute<km>      AvgEUCLDistance := sum(Matrix/Tij * Matrix/Net_Dij, Matrix/i);
			// attribute<float64> ACCi            := Matrix/Ai;
			// attribute<km>      max_Net_Di      := max(Matrix/Net_Dij, Matrix/i);
			// attribute<km>      max_EUCL_Di     := max(Matrix/EUCL_Dij, Matrix/i);
			// attribute<float64> PotWalk         := sum(Matrix/Tij * Matrix/WALKij, Matrix/i);
			// attribute<float64> PotCycle        := sum(Matrix/Tij * Matrix/CYCLij, Matrix/i);
		// }
		
		// unit<uint32> PerDestination := Destinations
		// {
			// attribute<float64> visits         := sum(Matrix/Tij, Matrix/j);
			// attribute<float64> ACCj           := Matrix/Aj; 
			// attribute<float64> AvgTime        := sum(Matrix/Tij * Matrix/Mij, Matrix/j) / visits;
			// attribute<float64> AvgNetDistance := sum(Matrix/Tij * Matrix/Net_Dij, Matrix/j) / visits;
		// }
		
		// unit<uint32> StoreOriginResults:= PerOrigin
		// , storagename = "='%LocalDataProjDir%/travel_proxy/region_origin_results/'+distdecay_functions/LabelText[infunc]+'.dbf'"
		// , storagetype = "gdalwrite.vect"
		// {
			// attribute<.>        orgid     := id(.);
			// attribute<float64>  ai        := ACCi;
			// attribute<float64>  avtime    := AvgTime;
			// attribute<float64>  avnetd    := AvgNetDistance;
			// attribute<float64>  aveucd    := AvgEUCLDistance;
			// attribute<float64>  fracwalk  := PotWalk;
			// attribute<float64>  fraccycle := PotCycle;
		// }
		
		// unit<uint32> StoreDestinationResults:= PerDestination
		// , storagename = "= '%LocalDataProjDir%/travel_proxy/region_destination_results/'+distdecay_functions/LabelText[infunc]+'.dbf'"
		// , storagetype = "gdalwrite.vect"
		// {
			// attribute<.>        orgid     := id(.);
			// attribute<float64>  aj        := ACCj;
			// attribute<float64>  avtime    := AvgTime;
			// attribute<float64>  avnetd    := AvgNetDistance;
			// attribute<float64>  visits    := PerDestination/visits;
			// attribute<uint32>   attract   := PerDestination/Population;
		// }
		
		// unit<uint32> Origin_Results_ReadOnly      : storagename = "= propvalue(StoreOriginResults, 'storagename')", storagetype = "gdal.vect", storagereadonly = "True";
		// unit<uint32> Destination_Results_ReadOnly : storagename = "= propvalue(StoreDestinationResults, 'storagename')", storagetype = "gdal.vect", storagereadonly = "True";
		
		// unit<uint32> revert_to_od_points:= OD_points 
		// {
			// attribute<Origin_Results_ReadOnly>      or_id     := rlookup(OD_points/OrgDomain_rel, value(Origin_Results_ReadOnly/orgid, uint32));
			// attribute<Destination_Results_ReadOnly> dr_id     := rlookup(OD_points/DestDomain_rel, value(Destination_Results_ReadOnly/orgid, uint32));
			// attribute<float32>                      ai        := MakeDefined(float32(Origin_Results_ReadOnly/ai[or_id]), 0f);
			// attribute<float32>                      avtimei   := MakeDefined(float32(Origin_Results_ReadOnly/avtime[or_id]) / Population[float32], 0f);
			// attribute<float32>                      avnetdi   := MakeDefined(float32(Origin_Results_ReadOnly/avnetd[or_id]) / Population[float32], 0f);
			// attribute<float32>                      aveucdi   := MakeDefined(float32(Origin_Results_ReadOnly/aveucd[or_id]) / Population[float32], 0f);
			// attribute<float32>                      avtimej   := MakeDefined(float32(Destination_Results_ReadOnly/avtime[dr_id]) / Population[float32], 0f);
			// attribute<float32>                      avnetdj   := MakeDefined(float32(Destination_Results_ReadOnly/avnetd[dr_id]) / Population[float32], 0f);
			// attribute<float32>                      fracwalki := MakeDefined(float32(Origin_Results_ReadOnly/fracwalk[or_id]) / Population[float32], 0f);
			// attribute<float32>                      fracyclei := MakeDefined(float32(Origin_Results_ReadOnly/fraccycle[or_id]) / Population[float32], 0f);
		// }
	// }
	
	Template Do_MergeProxies_T
	{
		parameter<distdecay_functions> infunc;
		
		unit<uint32> mergeProxy:= = 'union_unit(Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points)'
		, storagename = "='%LocalDataProjDir%/travel_proxy/mozaiks/'+distdecay_functions/LabelText[infunc]+'.shp'"
		, storagetype = "gdalwrite.vect"
		{
			attribute<LambertEA> geometry := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/geometry)';
			attribute<float32>   Pop      := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/population[float32])';
			attribute<float32>   Ai       := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/Ai)';
			attribute<float32>   avnetdi  := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/avnetdi)';
			attribute<float32>   aveucdi  := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/aveucdi)';
			attribute<float32>   avtimei  := = 'union_data(.,Results_per_distdecay/'+distdecay_functions/LabelText[infunc]+'/revert_to_od_points/avtimei)';
		}
	}
}